<html>
  <head>
    <title>Lesson</title>
    <link rel="stylesheet" href="stylesheet.css" type="text/css" />
    <script src="script.js" defer></script>
    <link rel="icon" href="./assets/lucide-BookText-Outlined.svg" />
  </head>
  <body>
    <header>
      <nav class="navbar">
        <div class="logo">
          <img src="./assets/lucide-BookText-Outlined.svg" />GIVE
        </div>
        <ul class="topics">
          <li><a href="./HTML.html">HTML</a></li>
          <li><a href="CSS.html">CSS</a></li>
          <li><a href="JavaScript.html">JavaScript</a></li>
          <li><a href="Python.html">Python</a></li>
          <li><a href="Django.html">Django</a></li>
          <li><a href="Flask.html">Flask</a></li>
          <li><a href="React.html">React</a></li>
          <li class="active-topic"><a href="NodeJS.html">NodeJS</a></li>
          <li><a href="SQL.html">SQL</a></li>
          <li><a href="Git.html">Git</a></li>
          <li><a href="Linux.html">Linux</a></li>
        </ul>

        <ul class="nav-links">
          <li><a href="../index.html" class="active">Home</a></li>
          <li><a href="../about.html">Lessons</a></li>
          <li><a href="../contact.html">Contact</a></li>
          <li><a href="../about.html">About</a></li>

        </ul>
      </nav>
    </header>

    <button id="menubtn">
      TOPICS <img src="./assets/lucide-ChevronRight-Outlined.svg" />
    </button>

    <div id="overlay"></div>
    <div class="sidebar" id="sidebar">
      <h3 class="title">Lessons Topics</h3>
      <ul class="lesson-list">
        <li><a href="#a1">Introduction to NodeJS</a></li>
        <li><a href="#a2">Core Modules</a></li>
        <li><a href="#a3">Web Servers</a></li>
        <li><a href="#a4">Database Integration</a></li>
        <li><a href="#a5">Implementation</a></li>
      </ul>
    </div>
    <div class="main">
      <h1 id="a1">NodeJS</h1>

      <h2>Introduction to NodeJS</h2>
      <p>
        Node.js, created by Ryan Dahl in 2009, took JavaScript from the browser
        to the server, using Chrome's V8 engine to execute code outside web
        pages. Its non-blocking, event-driven architecture revolutionized
        backend development by handling thousands of concurrent connections
        efficiently through a single thread. Node.js introduced the npm
        ecosystem, now the world's largest software registry, enabling rapid
        development through reusable packages. Understanding Node's core—the
        event loop, libuv for I/O operations, and the module system—reveals how
        JavaScript handles tasks traditionally reserved for languages like Java
        or Python.
      </p>

      <h2 id="a2">Core Modules</h2>
      <p>
        Node.js provides built-in modules for essential operations: fs for file
        system access, http for creating servers, path for file path
        manipulation, and events for custom event handling. The asynchronous
        nature of Node.js requires understanding callbacks, Promises, and
        async/await patterns. The callback pattern initially dominated but led
        to "callback hell"; Promises provided cleaner chaining, and async/await
        made asynchronous code appear synchronous. Error handling differs
        significantly from synchronous code—unhandled promise rejections and
        callback errors require specific patterns to prevent crashes in
        production applications.
      </p>

      <h2 id="a3">Web Servers</h2>
      <p>
        Node.js excels at creating lightweight, fast web servers. The http
        module provides low-level server creation, while frameworks like Express
        simplify routing, middleware, and request handling. Middleware functions
        process requests in a chain, enabling features like authentication,
        logging, and body parsing. RESTful API development involves proper HTTP
        method usage, status codes, error handling, and request validation.
        Real-world development requires understanding CORS, security headers,
        rate limiting, and input sanitization to create production-ready APIs
        that serve web, mobile, and third-party clients.
      </p>

      <h2 id="a4">Database Integration and Real-Time Communication</h2>
      <p>
        Node.js connects to various databases: MongoDB with Mongoose (NoSQL),
        PostgreSQL/MySQL with Sequelize or Knex (SQL), and Redis for caching.
        Each requires understanding connection pooling, migrations, and query
        optimization. Real-time applications use WebSockets through libraries
        like Socket.io, enabling bidirectional communication for chat,
        notifications, and collaborative features. File uploads, streaming data,
        and working with buffers require understanding Node's stream
        API—processing data in chunks without loading entire files into memory,
        crucial for performance with large files.
      </p>
      <h2 id="a5">Implementation</h2>
      <p>
        Production Node.js applications require process managers (PM2), reverse
        proxies (Nginx), environment configuration, logging, and monitoring. The
        Node.js ecosystem includes testing frameworks (Jest, Mocha), deployment
        platforms (AWS, Heroku, Vercel), and architectural patterns
        (microservices, serverless). Security considerations include dependency
        auditing, SSL/TLS configuration, and protection against common
        vulnerabilities. Modern Node.js development involves TypeScript
        integration, containerization with Docker, and understanding the event
        loop's impact on performance for CPU-intensive tasks versus I/O
        operations.
      </p>
    </div>
  </body>
</html>
